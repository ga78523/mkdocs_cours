# Algorithmes sur les graphes

## Repr√©sentations d'un graphe

### Rappels et exemple

Un graphe est un objet math√©matique (tr√®s utilis√©, notamment en informatique) constitu√© de sommets reli√©s entre eux par des ar√™tes (ou des arcs).

Exemple de graphe :

<figure markdown>
```mermaid
flowchart LR
    title[Graphe1]
    B((b)) <--> A((a))
    A <--> C((c))
    B <--> D((d))
    C <--> D
    B <--> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))
```
</figure>

Math√©matiquement, on peut d√©finir un graphe ùê∫ par un couple $G = (V, E)$ avec :

* $V$ un ensemble de sommets (vertices) (on dit aussi n≈ìuds ou points)
* *E* un ensemble d‚Äôar√™tes (edges) (on dit aussi arcs, liens ou lignes)
* Chaque ar√™te est d√©finie par une paire de deux sommets distincts :

$E \subset \{\{x,y\}|(x,y) \in V^2 ‚àß x \neq ùë¶\}$

*Remarque* : Cette expression math√©matique signifie que E est un sous-ensemble de l'ensemble de toutes les paires non ordonn√©es d'√©l√©ments distincts de V. Plus pr√©cis√©ment :

1. $V^2$ repr√©sente le produit cart√©sien de V avec lui-m√™me, c'est-√†-dire l'ensemble de tous les couples (x,y) o√π x et y sont des √©l√©ments de V.

2. La condition $x \neq y$ exclut les paires o√π les deux √©l√©ments sont identiques.

3. $\{\{x,y\}|(x,y) \in V^2 ‚àß x \neq y\}$ est l'ensemble de toutes les paires non ordonn√©es $\{x,y\}$ telles que x et y sont des √©l√©ments distincts de V.

4. $E \subset$ indique que E est un sous-ensemble de cet ensemble de paires.

En termes simples, E est un ensemble de paires d'√©l√©ments distincts de V, o√π l'ordre des √©l√©ments dans chaque paire n'est pas important. Cette notation est souvent utilis√©e pour d√©crire les ar√™tes d'un graphe non orient√©, o√π V serait l'ensemble des sommets et E l'ensemble des ar√™tes .

<!-- 
![Graphe exemple](img_graphes/img1.png) -->

### Repr√©sentation √† l'aide d'un dictionnaire

On peut impl√©menter ce graphe en Python par un dictionnaire :

```python
G = {}
G['a'] = ['b','c']
G['b'] = ['a','d','e']
G['c'] = ['a','d']
G['d'] = ['b','c','e']
G['e'] = ['b','d','f','g']
G['f'] = ['e','g']
G['g'] = ['e','f','h']
G['h'] = ['g']
```

!!! example "Exercice 1"
    Apr√®s avoir impl√©menter le graphe G. √âcrire des fonctions pour obtenir :

    * Nombre de sommets 
    * Nombre d'ar√™tes
    * Degr√© d'un sommet
    * Sommet de plus haut degr√©
    * Voisins d'un sommet
  
Si on le d√©sire, nous pouvons √† partir du dictionnaire G g√©n√©rer √©galement la matrice d'adjacence :

``` py linenums="1"
liste = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
n = len(liste)
A = [[0] * n for i in range(n)]
for i in range(n):
    for j in range(n):
        if liste[j] in G[liste[i]]:
            A[i][j] = 1
``` 

### A l'aide d'une liste de liste

Nous avons vu pr√©c√©dement que un graphe pouvait √™tre repr√©sent√© par une matrice d'adjacence.

``` py linenums="1"

A = [[0, 1, 1, 0, 0, 0, 0, 0],
[1, 0, 0, 1, 1, 0, 0, 0],
[1, 0, 0, 1, 0, 0, 0, 0],
[0, 1, 1, 0, 1, 0, 0, 0],
[0, 1, 0, 1, 0, 1, 1, 0],
[0, 0, 0, 0, 1, 0, 1, 0],
[0, 0, 0, 0, 1, 1, 0, 1],
[0, 0, 0, 0, 0, 0, 1, 0]]
```

!!! example "Exercice 2"
    Impl√©menter le graphe G avec cette matrice.
    √âcrire les m√™mes fonctions que pr√©c√©demment.


    * Nombre de sommets 
    * Nombre d'ar√™tes
    * Degr√© d'un sommet
    * Sommet de plus haut degr√©
    * Voisins d'un sommet

!!! example "Exercice 3"
    Impl√©menter le graphe du r√©seau social suivant et determiner celui qui a le plus d‚Äôamis.
    

    Un r√©seau social comporte 6 abonn√©s (A, B, C, D, E et F) o√π :

    * A est ami avec B, C et D
    * B est ami avec A et D
    * C est ami avec A, E et D
    * D est ami avec tous les autres abonn√©s
    * E est ami avec C, D et F
    * F est ami avec E et D
    
<figure markdown>
![Graphe exemple](img_graphes/img2.png){width=250px}
</figure>

### √Ä l'aide d'une biblioth√®que

La biblioth√®que `networkX`  permet de manipuler des graphes.

Pour impl√©menter le graphe G, on commence par importer le module.

``` py linenums="1"
import networkx as nx
```

On cr√©e un graphe vide.

``` py linenums="1"
#cr√©ation du graphe
g1 = nx.Graph()
```

On ajoute les sommets (appel√©s node ou vertex)

``` py linenums="1"
#cr√©ation des sommets
g1.add_node('a')
g1.add_node('b')
g1.add_node('c')
g1.add_node('d')
g1.add_node('e')
g1.add_node('f')
g1.add_node('g')
g1.add_node('h')
```

On ajoute les ar√™tes (appel√©s edge)

``` py linenums="1"
#Cr√©ation des ar√™tes
g1.add_edge('a', 'b')
g1.add_edge('a', 'c')
g1.add_edge('b', 'd')
g1.add_edge('b', 'e')
g1.add_edge('c', 'd')
g1.add_edge('d', 'e')
g1.add_edge('e', 'g')
g1.add_edge('e', 'f')
g1.add_edge('g', 'f')
g1.add_edge('g', 'h')
```

On peut visualiser le graphe gr√¢ce √† matplotlib et la fonction draw. Ici on a de plus configur√© l‚Äôaffichage pour que les √©tiquettes des sommets soient affich√©es, la taille des sommets soit de 800, la couleur de fond des sommets gris clair.

``` py linenums="1"
import matplotlib.pyplot as plt

nx.draw(g1, with_labels = True, 
        font_weight = 'bold',
        node_size = 800,
        node_color = 'lightgrey')
plt.show()
```

On peut √©galement le faire avec des listes de sommets et d‚Äôar√™tes :

``` py linenums="1"
import networkx as nx 
import matplotlib.pyplot as plt

#cr√©ation des sommets
liste1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] 
g2 = nx.Graph()
g2.add_nodes_from(liste1)

#cr√©ation des ar√™tes
liste2=[('a','b'),('a','c'),('b','d'),('b','e'),('c','d'),('d','e'),('e','g'),('e','f'),('g','f'),('g','h')]
g2.add_edges_from(liste2)

#cr√©ation du graphique
nx.draw(g2, with_labels=True,
        font_weight='bold',
        node_size=800,
        node_color='lightgrey')
plt.show()
```

Pour la matrice d‚Äôadjacence : **networkx** propose une m√©thode `nx.adjacency_matrix(g2)` qui stocke les coefficient saij de la matrice d‚Äôadjacence. Il suffit alors de remplir un tableau avec ces coefficients

``` py linenums="1"
B = nx.adjacency_matrix(g2)
print(B[(0,0)])
n=len(liste1)
A=[[0]*n for i in range(n)]
for i in range(n):
    for j in range(n):
        A[i][j]= B[(i,j)]
        
        
print(A)
```

La documentation de NetworkX est divis√©e en sections. Il existe notamment :

* une section pour obtenir les m√©thodes sur [https://networkx.org/documentation/stable/reference/functions.html](les sommets et les ar√™tes) ;
* une section pour obtenir les [https://networkx.org/documentation/stable/reference/algorithms/index.html](algorithmes disponibles) ;
* on pourra aussi consulter le [https://networkx.org/documentation/stable/tutorial.html](tutoriel) de **NetworkX**
  
Voici quelques fonctions  :

* degr√©s d‚Äôun sommet du graphe g : `g.degree('a')`
* nombre de sommets du graphe g : `g.number_of_nodes()`
* nombre d‚Äôarcs du graphe g : `g.number_of_edges()`
* `g.predecessors(i)` : liste des pr√©decesseurs du sommet $i$
* `g.successors(i) : liste des successeurs du sommet $i$
* `g.neighbors(i)` : liste des voisins du sommet $i$

!!! example "Exercice 4"
    Tester ces diff√©rents programmes.
    √âcrire des fonctions permettant d‚Äôobtenir les informations suivantes sur le graphe G :

    * le nombre de sommets du graphe ;
    * le nombre d‚Äôar√™tes du graphe ;
    * le degr√© d‚Äôun sommet ;
    * le sommet de plus haut degr√© ;
    * les voisins d‚Äôun sommet

!!! example "Exercice 5"
    Impl√©menter le graphe du r√©seau social suivant et faire afficher celui qui a le plus d‚Äôamis un r√©seau social comporte 6 abonn√©s (A, B, C, D, E et F) o√π :

    * A est ami avec B, C et D
    * B est ami avec A et D
    * C est ami avec A, E et D
    * D est ami avec tous les autres abonn√©s
    * E est ami avec C, D et F
    * F est ami avec E et D

<figure markdown>
![img2](img_graphes/img2.png){width=250px}
</figure>

## Principe des diff√©rents parcours

Un parcours de graphe est un algorithme consistant √† explorer tous les sommets d'un graphe de proche en proche √† partir d'un sommet initial. Ces parcours sont notamment utilis√©s pour rechercher un plus court chemin (et donc dans les GPS) ou pour trouver la sortie d'un labyrinthe...

Tous les parcours suivent plus ou moins le m√™me algorithme de base :

* On visite un sommet A. On cr√©e une structure $S$ qui contiendra au d√©part l'ensemble des voisins de $A$ .
* Tant que $S$ n‚Äôest pas vide :

    * on choisit un sommet s de $S$
    * on visite s
    * on ajoute √† $S$ tous les voisins de s pas encore visit√©s

Le choix de la structure de l'ensemble $S$ est pr√©pond√©rant:

* Si on choisit une file (FIFO): on visitera les sommets dans l'ordre d'arriv√©e, donc les plus proches du sommet pr√©c√©dent. On obtient donc un parcours en largeur nomm√© Breadth First Search ou  BFS.
* Si on choisit une pile (LIFO): on visitera d'abord les derniers sommets arriv√©s, donc on parcourt le graphe en visitant √† chaque √©tape un voisin du pr√©c√©dent. On obtient donc un parcours en profondeur nomm√© Depth First Search ou DFS.

**Remarque  :**   parcourir simplement le dictionnaire ou la matrice d‚Äôun graphe n‚Äôest pas consid√©r√© comme un parcours de graphe.

### Le parcours en largeur (Breadth First Search ou BFS)

#### Principe

Parcourir un graphe en largeur √† partir d'un sommet consiste √† visiter le sommet puis ses enfants, puis les enfants de ses enfants....

Comme nous l'avons vu dans le chapitre pr√©c√©dent, nous allons utiliser une file et une liste pour marquer les sommets visit√©s.

#### Exemple

<figure markdown>
```mermaid
flowchart LR
    B((b)) <--> A((a))
    A <--> C((c))
    B <--> D((d))
    C <--> D
    B <--> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))
```
</figure>



Voici le code pour cr√©er le dictionnaire qui repr√©sente le graphe  pr√©c√©dent et une fonction qui nous retourne la liste des voisins.

``` py linenums="1"
G = dict()
G['a'] = ['b','c']
G['b'] = ['a','d','e']
G['c'] = ['a', 'd']
G['d'] = ['b','c','e']
G['e'] = ['b','d', 'f', 'g']
G['f'] = ['e', 'g']
G['g'] = ['e', 'f', 'h']
G['h'] = ['g']

def voisins(G, sommet):
    return G[sommet]
``` 

!!! example "Exercice 1"
    Impl√©menter ce graphe et tester la fonction voisins}

Pour r√©aliser le parcours en largeur, on dispose d'un graphe (`G`, d'une liste (`sommet_visite`) et d'une file `f`. 

On prend `b` comme sommet de d√©part. On l'enfile.

Puis, tant que la file n'est pas vide (boucle `while`) :

* On d√©file `f` dans une variable `tmp`  ;
* Si `tmp` n'est pas dans `sommet_visite`, alors on l'ajoute √† `sommet_visite`.
* Pour chaque voisin de `tmp` : s'il n'est ni dans `sommet_visite` ni dans la file, on l'enfile.
* On renvoie `sommet_visite`.

Voici l'√©volution des contenus des variables pour les deux premiers tours de la boucle `while` :

**√âTAPE 1 :**

```py linenums="1"
tmp = 'b'
sommet_visite = ['b']
f = 'a', 'd', 'e'
```

<!-- <figure markdown>
```mermaid
flowchart LR
    B((b))-->A((a))
    A <--> C((c))
    B --> D((d))
    C <--> D
    B --> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))

style B fill:#ccffcc,color:black;
```
</figure> -->

<figure markdown>
![etape1](img_graphes/etape1.png)
</figure> 


**√âTAPE 2 :**
```py linenums="1"
tmp = 'a'
sommet_visite = ['b', 'a']
f = 'd', 'e', 'c'
```
<!-- 
<figure markdown>
```mermaid
flowchart LR
    B((b))-->A((a))
    A --> C((c))
    B --> D((d))
    C <--> D
    B --> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))

style B fill:#ccffcc,color:black;
style A fill:#ccffcc,color:black;
```
</figure>
 -->
<figure markdown>
![etape1](img_graphes/etape2.png)
</figure>

!!! example "Exercice 2"
    Compl√©ter le contenu des variables `tmp`, `sommet_visite` et `file`.

**√âTAPE 3 :**
``` py
tmp = 
sommet_visite = 
f = 
```

<figure markdown>
![etape1](img_graphes/etape3.png)
</figure>

**√âTAPE 4 :**

``` py
tmp = 
sommet_visite = 
f = 
``` 

<figure markdown>
![etape1](img_graphes/etape4.png)
</figure>

**√âTAPE 5 :**

``` py
tmp = 
sommet_visite = 
f = 
```

<figure markdown>
![etape1](img_graphes/etape5.png)
</figure>

**√âTAPE 6 :**

``` py
tmp = 
sommet_visite = 
f = 
``` 

<figure markdown>
![etape1](img_graphes/etape6png.png)
</figure>

**√âTAPE 7 :**
``` py
tmp = 
sommet_visite = 
f = 
```

<figure markdown>
![etape1](img_graphes/etape7.png)
</figure>

**√âTAPE 8 :**

``` py
tmp = 
sommet_visite = 
f = 
```

<figure markdown>
![etape1](img_graphes/etape8.png)
</figure>

Au final, l'arborescence associ√©e au parcours peut donc √™tre mod√©lis√©e de la fa√ßon suivante :

<figure markdown>
![etape1](img_graphes/resultat_graphe.png){width=250px}
</figure>

Le parcours en largeur nous donne donc : ['b', 'a', 'd', 'e', 'c','f', 'g', 'h']

#### Impl√©mentation du BFS en Python

Voici une classe `File` dans laquelle on a rajout√© une m√©thode `present(self,x)` qui renvoie vrai si x est dans la file.

**Remarque :** Vous pouvez aussi utiliser votre propre classe `File`

``` py linenums="1"
class File:
    ''' classe File '''
    def __init__(self):
        self.L = []

    def vide(self):
        return self.L == []

    def defiler(self):
        assert not self.vide(), 'file vide'
        return self.L.pop(0)

    def enfiler(self, x):
        self.L.append(x)

    def taille(self):
        return len(self.L)

    def sommet(self):
        return self.L[0]

    def present(self,x):
        return x in self.L
```

Et voici l'algorithme du BFS :

```plaintext
fonction parcours_largeur(G, sommet):
    sommet_visite ‚Üê []
    f ‚Üê File()
    f.enfiler(sommet)
    
    Tant que f n‚Äôest pas vide faire :
        tmp ‚Üê f.defiler()
        afficher tmp
        
        Si tmp n‚Äôest pas dans sommet_visite alors
            ajouter tmp √† sommet_visite
        Pour chaque voisin de tmp faire
            Si voisin n'est pas dans sommet_visite et n'est pas dans la file alors :
                    f.enfiler(voisin)
    Fin Tant que
    
    renvoyer sommet_visite
```

!!! example "Exercice 3"
    Impl√©menter cet algorithme en Python et tester le sur notre Graphe G

#### BFS - version r√©cursive

La pr√©sence d‚Äôune boucle while nous sugg√®re la version r√©cursive de cet algorithme. On dispose
d‚Äôun graphe, d‚Äôune file contenant le sommet de d√©part, d‚Äôune liste, contenant le sommet de d√©part
et qui nous servira √† marquer les sommets visit√©s.
Le processus :

1. on d√©file la file dans une variable tmp (on l‚Äôaffiche)
2. pour chaque voisin non d√©j√† visit√© de tmp
3. on le note comme visit√©
4. on l‚Äôenfile
5. on recommence √† partir de l‚Äô√©tape 1
Le processus s‚Äôarr√™te quand la file est vide.
Voici le programme :

``` plaintext
def bfs_rec(G, f, sommets_visites):
    if f.vide():
        return None
    tmp = f.defiler()
    print(tmp, end='')
    for u in voisins(G, tmp):
        if u not in sommets_visites:
            sommets_visites.append(u)
            f.enfiler(u)
            bfs_recur(G, f,sommets_visites)

f = File()
sommets_visites = []
sommet = 'b'
f.enfiler(sommet)
sommets_visites.append(sommet)
bfs_recur(G, f, sommmets_visites)
```

Exercice 4 :
    Faire fonctionner ce programme pour notre graphe.

#### Application : un chemin entre deux sommets

L‚Äôalgorithme BFS d√©couvre les sommets ¬´par cercles concentriques¬ª autour du point de d√©part.
On d√©couvre d‚Äôabord tous les sommets √† la distance 1 du point de d√©part, puis √† la distance 2, puis
3, etc.

Un sommet situ√© √† la distance 5 sera d√©couvert en tant que voisin d‚Äôun sommet √† la distance 4,
qui lui-m√™me aura √©t√© d√©couvert gr√¢ce √† un sommet √† la distance 3, qui lui-m√™me...
On reprend notre graphe.

<figure markdown>
```mermaid
flowchart LR
    B((b)) <--> A((a))
    A <--> C((c))
    B <--> D((d))
    C <--> D
    B <--> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))
```
</figure>

Par exemple : a-b-e-g-h est l‚Äôun des chemins possibles entre a et h.

La m√©thode consiste √† m√©moriser les sommets voisins du sommet visit√© comme cl√© d‚Äôun dictionnaire et ayant pour valeur son parent (le sommet visit√©).

Le sommet de d√©part n‚Äôaura pas de parent (None).

A la fin, notre dictionnaire sera : '{‚Äôa‚Äô : None, ‚Äôb‚Äô : ‚Äôa‚Äô, ‚Äôc‚Äô : ‚Äôa‚Äô, ‚Äôd‚Äô : ‚Äôb‚Äô, ‚Äôe‚Äô : ‚Äôb‚Äô, ‚Äôf‚Äô : ‚Äôe‚Äô, ‚Äôg‚Äô : ‚Äôe‚Äô, ‚Äôh‚Äô : ‚Äôg‚Äô}'

Il nous faudra lire ce dictionnaire pour pouvoir √©tablir le chemin entre a et h. h a pour parent e
qui a pour parent b et qui a pour parent a. D‚Äôo√π le chemin : a - b - e - g - h.


``` plaintext
fonction parcours_largeur(G_depart):
    parents <- dict()
    sommet_visite <- []
    f <- File()
    f.enfiler(depart)
    parents[depart] <- None
    tant que f n'est pas vide faire :
        on d√©file f dans tmp
        Si tmp n'est pas dans sommet_visite alors
            l'ajouter √† sommet_visite
        Pour chaque voisin de tmp faire :
            Si il n'est pas dans sommet_visite et pas dans la file alors :
                l'enfiler
                parents[el] <- tmp
    fin tant que
    renvoyer parents
```

Cette fonction renvoie un dictionnaire qui contient les sommets visit√©s (cl√©s) et leurs parents
(valeurs).

Il faut maintenant exploiter ce dictionnaire pour faire afficher un chemin entre deux sommets.
C‚Äôest ce que r√©alise cette fonction qui prend en param√®tre le sommet d‚Äôarriv√©e et le dictionnaire
parent.

```py linenums="1"
def solution(end, parent):
    chemin = []
    courant = end
    while courant != None :
        chemin = [courant] + chemin
        courant = parent[courant]
    return chemin
```

!!! example "Exercice 5"
    Impl√©menter l‚Äôalogorithme en Python et la fonction pour afficher un chemin entre les sommets
    b et h de notre graphe.

!!! example "Exercice 6"
    Reprendre ce travail en utilisant la version r√©cursive du BFS.
    Il faudra ensuite une fonction pour recr√©er le chemin.

**Remarque :** Si le graphe est connexe, tout parcours BFS au d√©part de A va parcourir l‚Äôint√©gralit√© du graphe, et donc passera par B √† un moment. Un chemin sera donc forc√©ment trouv√© entre A et B.

Comment est-on s√ªr que ce chemin trouv√© est le plus court ?

La d√©couverte des sommets par cercles concentriques entre A et B nous assure qu‚Äôon ne peut pas
rater le point B : s‚Äôil est √† la distance k de A, il sera forc√©ment visit√© puisque tous les sommets √† la distance k vont passer par la liste d‚Äôattente, apr√®s les sommets de distance k-1 et avant les sommets de distance k+1.

Lorsqu‚Äôon remontera de B vers A en passant par les sommets parents successifs, il ne peut y
avoir qu‚Äôun seul sommet par ¬´couche¬ª : le chemin sera donc exactement de longueur k, il sera donc
minimal.

### Le parcours en profondeur(Depth First Search ou DFS)

#### Principe

Parcourir un graphe en profondeur √† partir d‚Äôun sommet, consiste √† explorer le graphe en suivant
un chemin. Lorsqu‚Äôon arrive sur un sommet qui n‚Äôa plus de voisins non visit√©s, on le marque. Puis
on remonte dans le chemin pour explorer les voisins non visit√©s d‚Äôun autre sommet...On utilise une
pile et deux listes.

#### Exemple

Prenons en exemple ce graphe :

<figure markdown>
```mermaid
flowchart LR
    B((b)) <--> A((a))
    A <--> C((c))
    B <--> D((d))
    C <--> D
    B <--> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))
```
</figure>

On dispose d‚Äôun graphe(G), de deux listes (sommets_visit√©s , sommets_ferm√©s) et d‚Äôune pile
(p). Le sommet de d√©part est par exemple ‚Äôg‚Äô, on l‚Äôempile. On met le sommet de d√©part dans la liste
sommets_visit√©s. Puis tant que la pile n‚Äôest pas vide :

* On r√©cup√®re le sommet de la pile dans une variable tmp
* voisins re√ßoit la liste des voisins de tmp non d√©j√† visit√©s
* Si voisins n‚Äôest pas vide :

    * v‚Üêun voisin choisi au hasard
    * sommets_visit√©s‚Üêv
    * On empile v

* Sinon :`

    * sommets_ferm√©s ‚Üê tmp
    * On d√©pile p

Voici les contenus des variables au premier tour de la boucle tant que :

<div style="text-align:center;font-size :x-large;font-style:bold"> Premier tour </div>

* tmp : `g`
* voisins : `[‚Äôe‚Äô, ‚Äôf‚Äô, ‚Äôh‚Äô]`
* v : `e`
* sommets_visit√©s : `[‚Äôg‚Äô, ‚Äôe‚Äô]`
* pile : `[‚Äôg‚Äô, ‚Äôe‚Äô]`
* sommets_ferm√©s : `[]`

<figure markdown>
![etape1_dfs](img_graphes/step1_dfs.png){width=500px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> Deuxi√®me tour </div>

* tmp : `e`
* voisins : `[‚Äôb‚Äô, ‚Äôd‚Äô, ‚Äôf‚Äô]`
* v : `b`
* sommets_visit√©s : `[‚Äôg‚Äô, ‚Äôe‚Äô, ‚Äôb‚Äô]`
* pile : `[‚Äôg‚Äô, ‚Äôe‚Äô, ‚Äôb‚Äô]`
* sommets_ferm√©s : `[]`

<figure markdown>
![etape1_dfs](img_graphes/step2_dfs.png){width=500px}
</figure>

!!! example "Exercice 7"
    Compl√©ter les contenus des variables

<div style="text-align:center;font-size :x-large;font-style:bold"> 3 eme tour </div>

* tmp :
* voisins :
* v : 
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s : 

<figure markdown>
![etape1_dfs](img_graphes/step4_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 4eme tour </div>

* tmp :
* voisins :
* v : 
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s : 

<figure markdown>
![etape1_dfs](img_graphes/step5_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 5eme tour </div>

* tmp :
* voisins :
* v : 
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s : 

<figure markdown>
![etape1_dfs](img_graphes/step6_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 6eme tour </div>

* tmp : []
* voisins : d
* v :  
* sommets_visit√©s : `[‚Äôg‚Äô, ‚Äôe‚Äô, ‚Äôb‚Äô, ‚Äôa‚Äô, ‚Äôc‚Äô, ‚Äôd‚Äô]`
* pile : `[‚Äôg‚Äô, ‚Äôe‚Äô, ‚Äôb‚Äô, ‚Äôa‚Äô, ‚Äôc‚Äô]`
* sommets_ferm√©s :  `[‚Äôd‚Äô]`

<figure markdown>
![etape1_dfs](img_graphes/step7_dfs.png){width=400px}
</figure>

!!! example "Exercice 8"
    Poursuivez

<div style="text-align:center;font-size :x-large;font-style:bold"> 7eme tour </div>

* tmp : 
* voisins : 
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step8_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 8eme tour </div>

* tmp : 
* voisins : 
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step9_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 9eme tour </div>

* tmp : 
* voisins : 
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step10_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 10eme tour </div>

* tmp : 
* voisins :
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step11_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 11eme tour </div>
* tmp : 
* voisins :
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step12_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 12eme tour </div>

* tmp : 
* voisins : 
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step13_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 13eme tour </div>

* tmp : 
* voisins : 
* v :  
* sommets_visit√©s : 
* pile :
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step14_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 14eme tour </div>

* tmp : 
* voisins :
* v :  
* sommets_visit√©s :
* pile :
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step15_dfs.png){width=400px}
</figure>

<div style="text-align:center;font-size :x-large;font-style:bold"> 15eme tour </div>

* tmp : 
* voisins :
* v :  
* sommets_visit√©s : 
* pile : 
* sommets_ferm√©s :  

<figure markdown>
![etape1_dfs](img_graphes/step16_dfs.png){width=400px}
</figure>

**Remarque :** Comme les choix dans la liste des voisins sont al√©atoires, il y a plusieurs parcours possibles.

Au final l‚Äôarborescence associ√©e au parcours peut  donc  √™tre  mod√©lis√©e  de  la  fa√ßon  suivante :

`[‚Äôd‚Äô, ‚Äôc‚Äô, ‚Äôa‚Äô, ‚Äôb‚Äô, ‚Äôf‚Äô, ‚Äôe‚Äô, ‚Äôh‚Äô, ‚Äôg‚Äô]`

<figure markdown>
![etape1_dfs](img_graphes/dfs_final.png){width=400px}
</figure>

#### DFS version 1

Voici une classe Pile :

``` py linenums="1"
class Pile:
    """classe Pile : cr√©ation d‚Äôune instance Pile avec une liste"""

    def __init__(self):
        self.L = []
        
    def vide(self):
        return self.L == []
        
    def depiler(self):
        assert not self.vide(), "Pile vide"
        return self.L.pop()

    def sommet(self):
        assert not self.vide(), "Pile vide"
        return self.L[-1]

    def empiler(self,x):
        self.L.append(x)
```

Vous pouvez √©galement utiliser votre propre classe Pile.Voici le code pour la cr√©ation du dictionnaire qui repr√©sente le graphe G et une fonction qui renvoie les voisins d‚Äôun sommet.

``` py linenums="1"
G = dict()
G['a'] = ['b','c']
G['b'] = ['a','d','e']
G['c'] = ['a','d']
G['d'] = ['b','c','e']
G['e'] = ['b','d','f','g']
G['f'] = ['e','g']
G['g'] = ['e','f','h']
G['h'] = ['g']

def voisin(G,sommet):
    return G[sommet]
```

Voici une ligne de code qui permet de r√©cup√©rer les voisins de tmp non d√©j√† visit√©s :

``` py linenums="1"
voisins = [y for y in voisin(G, tmp) if y not in sommets_visites]
```

La biblioth√®que `random`  permet un choix al√©atoire dans une liste :

``` py linenums="1"
import random 
v = random.choice(voisins)
```

``` plaintext title="Algorithme DFS"
fonction parcours_profondeur(G,sommet):
    sommets_visites <- []
    sommet_fermes <- []
    p <- Pile()
    sommets_visites <- sommet
    on empile le sommet dans p
    Tant que p n'est pas vide faire
        tmp <- le sommet de la pile
        voisins <- la liste des voisins de tmp non d√©j√† visites
        Si voisins n'est pas vide alors
            v <- un voisin au hasard
            sommets_visites <- v
            on empile v
        Sinon
            sommets_fermes <- tmp
            on depile p
    fin tant que 
    renvoyer sommets_fermes
```


!!! example "Exercice 9"
    Impl√©menter cet algorithme en Python et tester le sur notre graphe G. 

**Remarque :** Comme les choix dans la liste des voisins sont al√©atoires, il y a plusieurs parcours possibles.

#### DFS version 2

``` py linenums="1"
def dfs_bis(G,sommet):
    p = Pile()
    sommets_visites = []
    p.empiler(sommet)
    while p.vide() == False:
        tmp = p.depiler()
        if tmp not in sommets_visites:                         
            sommets_visites.append(tmp)
            #print(tmp, end=" ")
            voisins = [y for y in voisin(G,tmp) if y not in sommets_visites]
        for vois in voisins:
            p.empiler(vois) 
    return sommets_visites
            
c = dfs_bis(G, 'g') 
print('\n')
print(c)
``` 

!!! example "Exercice 10"
    Tester cette version sur notre graphe G.

#### DFS  version 3 (r√©cursive)

On peut utiliser un algorithme r√©cursif pour parcourir un graphe en profondeur. En voici la description :

1. On part d‚Äôun n≈ìud du graphe.
2. On le marque comme visit√© s‚Äôil ne l‚Äôest pas d√©j√†.
3. Pour chacun de ses voisins non visit√©s, on reprend √† partir du 1.

Il y a une "boucle" du 3. au 1. Cela pr√©sage une m√©thode r√©cursive. Voici l‚Äôalgorithme davantage d√©taill√© :

``` plaintext

Donn√©es :
G est un graphe
sommet est un sommet du graphe
sommets_visites est une liste

fonction dfs(G,sommet):
    Si le sommet n'est pas dans la liste sommets_visites alors
        on le met dans la liste
    voisins <- la liste des voisins de sommet non deja visites
    Pour chaque voisin dans voisins faire 
        dfs(G,voisin)
    renvoyer sommets_visites
```

!!! example "Exercice 11"
    √âcrire la fonction dfs et la faire fonctionner avec notre graphe avec comme sommet de d√©part ‚Äôg‚Äô.

**Remarque :** Le choix du premier voisin est le premier de la liste voisins qui correspond √† celle implant√©e lors de la cr√©ation du graphe: `G['g'] = ['e', 'f', 'h']`, en la modifiant par `G['g'] = ['f', 'e', 'h']`, vous obtiendrez un autre parcours...

### Application : un chemin entre deux sommets

L‚Äôobjectif est de faire afficher un chemin entre deux sommets d‚Äôun graphe.

<figure markdown>
```mermaid
flowchart LR
    B((b)) <--> A((a))
    A <--> C((c))
    B <--> D((d))
    C <--> D
    B <--> E((e))
    D <--> E
    E <--> G((g))
    E <--> F((f))
    G<--> F
    G<-->H((h))
```
</figure>

Par exemple : `a - b - e - g - h` est l‚Äôun des chemins possible entre a et h

La m√©thode consiste √† m√©moriser les sommets voisins du sommet visit√© comme cl√©s d‚Äôun dictionnaire et ayant pour valeur son parent(le sommet visit√©).Le sommet de d√©part n‚Äôaura bien entendu pas de parent (None).

``` plaintext linenums="1" title="Algorithme DFS modifi√©"

Donn√©es :
G est un graphe
depart : un sommet du graphe
arrivee : un sommet du graphe
sommets_visites est une liste
parents est un dictionnaire
parents[depart] = None

fonction dfs(G,depart):
    Si depart n'est pas dans la liste sommets_visites alors
        on le met dans la liste
    voisins <- la liste des voisins de depart non deja visites
    Pour chaque voisin dans voisins faire 
        parents[voisin] = depart
        dfs(G,voisin)
    renvoyer parents
```

Cette fonction renvoie un dictionnaire qui contient les sommets visit√©s(cl√©s) et leurs parents(valeurs).Il faut maintenant exploiter ce dictionnaire pour faire afficher un chemin entre deux sommets. C‚Äôest ce que r√©alise cette fonction qui prend en param√®tre l‚Äôarriv√©e et le dictionnaire parents.

``` py linenums="1"
def solution(end, parents):
    chemin = []
    courant = end
    while courant !=None:
        chemin = [courant] + chemin
        courant = parents[courant]
    return chemin
```

!!! example "Exercice 12"
    Impl√©menter l‚Äôalgorithme en Python et la fonction Solution pour faire afficher un chemin entre les sommets b et h de notre graphe G.

!!! example "Exercice 13"
    Reprendre ce dernier travail en utilisant et modifiant la fonction `dfs_bis`.

## Recherche de cycle

### Rappels

Une cha√Æne est une suite d‚Äôar√™tes cons√©cutives dans un graphe, un peu comme si on se promenait sur le graphe. On la d√©signe par les lettres des sommets qu‚Äôelle comporte. On utilise le terme de cha√Æne pour les graphes non orient√©s et le terme de chemin pour les graphes orient√©s.

Un cycle est une cha√Æne qui commence et se termine au m√™me sommet.

<figure markdown>
![img1](img_graphes/cycle_img1.png){width=350px}
</figure>

a - b - e - d - c - a est un cycle

L‚Äôexistence de cycle dans un graphe permet d'effectuer un trajet en revenant √† son point de d√©part sans faire demi-tour...

<figure markdown>
![img1](img_graphes/cycle_img2.png){width=350px}
</figure>

### Algorithme de la pr√©sence d'un cycle

Voici un programme qui d√©tecte la pr√©sence d‚Äôun cycle dans un graphe connexe non-orient√©:

``` py linenums="1"
def detection_cycle(G, sommet):
    sommets_visites = []
    f = File()
    sommets_visites.append(sommet)
    f.enfiler((sommet, -1))
    while not f.vide():
        (tmp, parent) = f.defiler()
        voisins = voisin(G, tmp)
        for vois in voisins:
            if vois not in sommets_visites:
                sommets_visites.append(vois)
                f.enfiler((vois, tmp))
            elif vois != parent:
                return True
    return False
```

!!! example "Exercice 1"
    1. Quel type de parcours utilise ce programme ?
    2. Quel est le type des √©l√©ments plac√©s dans la file ?

!!! example "Exercice 2"
    Faire fonctionner ce programme √† la main sur ce graphe en partant du sommet 'a' :

    <figure markdown>
    ![img1](img_graphes/cycle_img3.png){width=350px}
    </figure>

    ** <div style="font-size=x-large">   1  tour<div>**

    * tmp :  
    * parent : 
    * f : 
    * voisins :
    * sommets_visites :
    * f :
  
    ** <div style="font-size=x-large">   2<>  tour<div>**

    * tmp :  
    *  parent : 
    * f : 
    * voisins :
    * sommets_visites :
    * f :

    ** <div style="font-size=x-large">   3  tour<div>**

    * tmp :  
    *  parent : 
    * f : 
    * voisins :
    * sommets_visites :
    * f :

    ** <div style="font-size=x-large">   4  tour<div>**

    * tmp :
    * parent : 
    * f : 
    * voisins :
    * sommets_visites :
    * f :

    ** <div style="font-size=x-large">   6  tour<div>**

    * tmp :  
    *  parent : 
    * f : 
    * voisins :
    * sommets_visites :
    * f :

!!! example "Exercice 3"
    Pour finir de vous convaincre...Faire  fonctionner  ce  programme  √†  la  main  pour  le  graphe  ci-dessous  en  partant  du sommet 'a'. Noter les contenus des variables au dernier tour.

<figure markdown>
![img1](img_graphes/cycle_img4.png){width=350px}
</figure>

## Bibliographie

* [https://informatique-lycee.forge.apps.education.fr/terminale_nsi/cours-terminale/](pixees)
* [https://glassus.github.io/terminale_nsi/T1_Structures_de_donnees/1.4_Graphes/cours/](Site de G.Lassus)
* [https://frederic-zinelli.gitlab.io/algographe/](site tr√®s int√©ressant pour dessiner, et coder un graphe. A voir !)